<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voto Anonimo – Link diretto</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #0f172a; color: #e2e8f0;
    }
    .wrap { max-width: 820px; margin: 0 auto; padding: 16px; }
    header, footer { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    header { padding: 8px 0; }
    .room, .self { font-size: 14px; opacity: 0.9; }
    .panel { background: #111827; border: 1px solid #1f2937; border-radius: 12px; padding: 16px; }
    .row { display: flex; gap: 8px; align-items: center; }
    .space { justify-content: space-between; }
    button {
      border: none; padding: 12px 16px; border-radius: 10px; cursor: pointer; font-weight: 600;
    }
    button.primary { background: #22c55e; color: #102a18; }
    button.ghost { background: transparent; color: #93c5fd; border: 1px solid #334155; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }

    .status { margin: 10px 0 2px; font-size: 14px; opacity: 0.9; }
    .q-label { font-size: 12px; letter-spacing: 0.06em; text-transform: uppercase; color: #9ca3af; margin-top: 12px; }
    .q-text { font-size: 20px; margin: 6px 0 10px; }

    .players { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; margin: 10px 0; }
    .player { background: #0b1220; border: 1px solid #1f2937; padding: 10px; border-radius: 10px; }
    .player input { margin-right: 8px; }

    .progress { margin: 10px 0; }
    .results-list { margin: 8px 0 0; padding-left: 18px; }
    .hidden { display: none; }

    @media (hover:hover) {
      button.primary:hover { filter: brightness(0.95); }
      button.ghost:hover { background: #0b1220; }
    }
  </style>
  <!-- Firebase (compat per semplicità in single-file) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="room" id="roomName">Stanza: …</div>
      <div class="self" id="selfName">Tu: …</div>
    </header>

    <section class="panel">
      <div class="row space">
        <button id="btnStart" class="primary">Via</button>
        <button id="btnNext" class="ghost">Nuova domanda</button>
      </div>

      <div id="status" class="status">Stato: in attesa…</div>

      <div id="questionBox" class="question hidden">
        <div class="q-label">Domanda</div>
        <div id="question" class="q-text">—</div>
      </div>

      <div id="voteBox" class="vote hidden">
        <div class="q-label">Scegli chi votare (non te stesso)</div>
        <div id="players" class="players"></div>
        <button id="btnVote" class="primary" disabled>Vota</button>
      </div>

      <div id="progressBox" class="progress hidden">
        Voti ricevuti: <span id="progNums">0/0</span>
      </div>

      <div id="resultsBox" class="results hidden">
        <div class="q-label">Classifica</div>
        <ol id="resultsList" class="results-list"></ol>
      </div>
    </section>

    <footer>
      Condividi questo link con <code>?r=nome-stanza</code> per entrare nella stessa stanza.
    </footer>
  </div>

<script>
/* ===========================
   1) CONFIGURA FIREBASE QUI
   =========================== */
// Vai su console.firebase.google.com → crea progetto → Realtime Database → copia la tua config:
const firebaseConfig = {
  // TODO: incolla qui la tua config Firebase (apiKey, authDomain, databaseURL, projectId, storageBucket, messagingSenderId, appId)
};

// ====== DOM/STATE ======
const qs = s => document.querySelector(s);
const roomNameEl = qs('#roomName');
const selfNameEl = qs('#selfName');
const statusEl = qs('#status');
const questionBox = qs('#questionBox');
const questionEl = qs('#question');
const voteBox = qs('#voteBox');
const playersEl = qs('#players');
const btnVote = qs('#btnVote');
const progressBox = qs('#progressBox');
const progNums = qs('#progNums');
const resultsBox = qs('#resultsBox');
const resultsList = qs('#resultsList');
const btnStart = qs('#btnStart');
const btnNext = qs('#btnNext');

// Ricava roomId da ?r= o #room o path /r/room
function getRoomId() {
  const params = new URLSearchParams(location.search);
  if (params.get('r')) return params.get('r').slice(0,100);
  if (params.get('room')) return params.get('room').slice(0,100);
  const h = (location.hash || '').replace(/^#/, '');
  if (h) return h.slice(0,100);
  const m = location.pathname.match(/\/r\/([^\/]+)/);
  if (m) return decodeURIComponent(m[1]).slice(0,100);
  return 'default';
}
const roomId = getRoomId();
roomNameEl.textContent = `Stanza: ${roomId}`;

// Etichette anonime
const ANIMALS = ["Volpe","Gufo","Lupo","Gatto","Cervo","Aquila","Delfino","Panda","Istrice","Tasso","Lontra","Falco","Riccio","Koala","Lince","Canguro","Orca","Squalo","Ghepardo","Tartaruga"];
function makeLabel(existing) {
  for (let i=0;i<2000;i++) {
    const a = ANIMALS[Math.floor(Math.random()*ANIMALS.length)];
    const n = Math.floor(Math.random()*90)+10;
    const c = `${a} ${n}`;
    if (!existing.has(c)) return c;
  }
  return `Anon-${Math.random().toString(36).slice(2,8)}`;
}

// Domande
const QUESTIONS = [
  "Chi è più puntuale?",
  "Chi sopravviverebbe più a lungo su un'isola deserta?",
  "Chi cucina meglio?",
  "Chi è più competitivo?",
  "Chi è più probabile che dimentichi un compleanno?",
  "Chi racconta le storie più divertenti?",
  "Chi ha più sangue freddo nelle emergenze?",
  "Chi è più nottambulo?",
  "Chi farebbe il detective migliore?",
  "Chi è più organizzato?",
  "Chi è più creativo?",
  "Chi è più avventuroso?",
  "Chi è più ironico?",
  "Chi si perde più facilmente?",
  "Chi è più diplomatico?",
  "Chi ha più spirito di iniziativa?",
  "Chi è più incline al rischio?",
  "Chi è più paziente?",
  "Chi è più tecnologico?",
  "Chi è più empatico?"
];

// Stato locale
let app, db, auth, uid=null, myLabel='…';
let participants = new Map(); // id -> {label}
let state = { phase:'idle', round:0, question:'', expectedVoters:{} };
let votes = {}; // uid -> targetId
let selectedTarget = null;
let hasVoted = false;

// UI helpers
function setStatus(txt){ statusEl.textContent = `Stato: ${txt}`; }
function showVotingUI(q){
  questionEl.textContent = q || '—';
  questionBox.classList.remove('hidden');
  voteBox.classList.remove('hidden');
  resultsBox.classList.add('hidden');
  progressBox.classList.remove('hidden');
  hasVoted = false; selectedTarget=null; btnVote.disabled = true;
  renderPlayersForVote();
}
function showResults(resultsMap){
  // resultsMap: { uid: {label, votes} }
  resultsList.innerHTML = '';
  const arr = Object.entries(resultsMap||{}).map(([id, obj]) => ({id, label: obj.label, votes: obj.votes||0}));
  arr.sort((a,b)=>b.votes-a.votes);
  for(const item of arr){
    const li = document.createElement('li');
    li.textContent = `${item.label} — ${item.votes}`;
    resultsList.appendChild(li);
  }
  resultsBox.classList.remove('hidden');
  voteBox.classList.add('hidden');
  progressBox.classList.add('hidden');
}
function renderPlayersForVote(){
  playersEl.innerHTML = '';
  const list = Array.from(participants.values()).filter(p => p.id !== uid);
  for(const p of list){
    const id = `p_${p.id}`;
    const label = document.createElement('label');
    label.className='player';
    label.innerHTML = `<input type="radio" name="target" id="${id}" value="${p.id}"> ${p.label}`;
    label.querySelector('input').addEventListener('change', (e)=>{
      selectedTarget = e.target.value;
      btnVote.disabled = !selectedTarget || hasVoted;
    });
    playersEl.appendChild(label);
  }
}

// Firebase init + join
async function init(){
  if(!firebaseConfig || !firebaseConfig.apiKey){
    alert('Config Firebase mancante: edita il file e incolla la tua configurazione.');
    return;
  }
  app = firebase.initializeApp(firebaseConfig);
  auth = firebase.auth();
  db = firebase.database();

  // Anonymous auth
  const cred = await auth.signInAnonymously();
  uid = cred.user.uid;

  // Prendi etichetta unica
  const partSnap = await db.ref(`rooms/${roomId}/participants`).get();
  const existingLabels = new Set();
  if (partSnap.exists()) {
    Object.values(partSnap.val()).forEach(p => { if (p && p.label) existingLabels.add(p.label); });
  }
  myLabel = makeLabel(existingLabels);
  selfNameEl.textContent = `Tu: ${myLabel}`;

  // Registra presenza + onDisconnect
  const meRef = db.ref(`rooms/${roomId}/participants/${uid}`);
  await meRef.set({ label: myLabel, joinedAt: firebase.database.ServerValue.TIMESTAMP });
  meRef.onDisconnect().remove();

  // Listeners
  db.ref(`rooms/${roomId}/participants`).on('value', snap=>{
    const val = snap.val() || {};
    const prevIds = new Set(participants.keys());
    participants = new Map(Object.entries(val).map(([id, v])=>[id,{id, label: v.label}]));

    // Se in votazione, rimuovi disconnessi da expectedVoters (se non hanno votato)
    if (state.phase === 'voting') {
      for(const oldId of prevIds){
        if(!participants.has(oldId) && state.expectedVoters && state.expectedVoters[oldId]){
          // prova a togliere da expectedVoters
          db.ref(`rooms/${roomId}/state/expectedVoters/${oldId}`).remove();
        }
      }
      // Aggiorna lista candidati
      renderPlayersForVote();
    }
  });

  db.ref(`rooms/${roomId}/state`).on('value', snap=>{
    state = Object.assign({phase:'idle', round:0, question:'', expectedVoters:{}}, snap.val()||{});
    if (state.phase === 'voting') {
      setStatus('votazione in corso');
      showVotingUI(state.question);
      const total = state.expectedVoters ? Object.keys(state.expectedVoters).length : 0;
      const voted = votes ? Object.keys(votes).length : 0;
      progNums.textContent = `${voted}/${total}`;
    } else if (state.phase === 'results') {
      setStatus('classifica visibile');
      questionEl.textContent = state.question || '';
      questionBox.classList.remove('hidden');
    } else {
      setStatus('in attesa');
      questionBox.classList.add('hidden');
      voteBox.classList.add('hidden');
      progressBox.classList.add('hidden');
      resultsBox.classList.add('hidden');
    }
  });

  db.ref(`rooms/${roomId}/votes`).on('value', snap=>{
    votes = snap.val() || {};
    if (state.phase === 'voting') maybeFinish();
    const total = state.expectedVoters ? Object.keys(state.expectedVoters).length : 0;
    const voted = votes ? Object.keys(votes).length : 0;
    progNums.textContent = `${voted}/${total}`;
    progressBox.classList.toggle('hidden', state.phase!=='voting');
  });

  db.ref(`rooms/${roomId}/results`).on('value', snap=>{
    const res = snap.val();
    if (res && state.phase === 'results') {
      showResults(res.tally || {});
    }
  });

  // UI ready
  questionBox.classList.add('hidden');
  voteBox.classList.add('hidden');
  resultsBox.classList.add('hidden');
  progressBox.classList.add('hidden');
  btnStart.disabled = false;
  btnNext.disabled = false;
}

// Avvio round
async function startRound(){
  if (!uid) return;
  // Crea mappa expectedVoters dagli attuali partecipanti
  const ev = {};
  for(const id of participants.keys()){ ev[id]=true; }
  const nextRound = (state.round || 0) + 1;
  const question = QUESTIONS[Math.floor(Math.random()*QUESTIONS.length)];

  const updates = {};
  updates[`rooms/${roomId}/state/phase`] = 'voting';
  updates[`rooms/${roomId}/state/round`] = nextRound;
  updates[`rooms/${roomId}/state/question`] = question;
  updates[`rooms/${roomId}/state/expectedVoters`] = ev;
  updates[`rooms/${roomId}/state/startedAt`] = firebase.database.ServerValue.TIMESTAMP;
  updates[`rooms/${roomId}/votes`] = null;
  updates[`rooms/${roomId}/results`] = null;

  await db.ref().update(updates);
}

// Voto
async function castVote(targetId){
  if (!targetId || hasVoted) return;
  // Evita auto-voto client-side
  if (targetId === uid) { alert('Non puoi votare te stesso.'); return; }
  // Scrivi solo se non esiste già (transaction)
  const myVoteRef = db.ref(`rooms/${roomId}/votes/${uid}`);
  await myVoteRef.transaction(curr => curr ? curr : targetId);
  hasVoted = true; btnVote.disabled = true;
  setStatus('voto registrato, in attesa degli altri…');
}

// Chiusura automatica quando tutti hanno votato
async function maybeFinish(){
  if (state.phase !== 'voting') return;
  const expectedCount = state.expectedVoters ? Object.keys(state.expectedVoters).length : 0;
  const votedCount = votes ? Object.keys(votes).length : 0;
  if (expectedCount>0 && votedCount >= expectedCount){
    // Prova a passare a results (solo un client "vince")
    const phaseRef = db.ref(`rooms/${roomId}/state/phase`);
    const tx = await phaseRef.transaction(curr => (curr==='voting' ? 'results' : curr));
    if (tx.committed && tx.snapshot.val()==='results') {
      // Siamo noi i "vincitori": calcola classifica e scrivi results
      const counts = {};
      for(const id of Object.keys(state.expectedVoters||{})){ counts[id]=0; }
      for(const [voter, target] of Object.entries(votes||{})){
        if (counts.hasOwnProperty(target)) counts[target] = (counts[target]||0)+1;
      }
      const tally = {};
      for(const id of Object.keys(state.expectedVoters||{})){
        const p = participants.get(id);
        tally[id] = { label: p ? p.label : id, votes: counts[id]||0 };
      }
      await db.ref(`rooms/${roomId}/results`).set({
        tally,
        totalVoters: expectedCount,
        closedAt: firebase.database.ServerValue.TIMESTAMP
      });
    }
  }
}

// Eventi UI
btnStart.addEventListener('click', startRound);
btnNext.addEventListener('click', startRound);
btnVote.addEventListener('click', ()=> {
  if (!selectedTarget) return;
  castVote(selectedTarget);
});

window.addEventListener('load', init);
</script>
</body>
</html>
